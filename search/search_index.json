{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo ao git-mini-book Reposit\u00f3rio para fins de estudo, criado para centralizar o conte\u00fado necess\u00e1rio para se adquirir profici\u00eancia com a ferramenta Git. O presente conte\u00fado deste projeto, foca em ser objetivo pra quem l\u00ea. As explica\u00e7\u00f5es visam atender o b\u00e1sico necess\u00e1rio para compreender como se utliza a ferramenta, assim como os seus benef\u00edcios. Este reposit\u00f3rio \u00e9 uma iniciativa para a cria\u00e7\u00e3o de cont\u00e9udo de forma colaborativa, Pull Requests s\u00e3o bem vindos! TODO: Sum\u00e1rio","title":"Bem vindo ao git-mini-book"},{"location":"#bem-vindo-ao-git-mini-book","text":"Reposit\u00f3rio para fins de estudo, criado para centralizar o conte\u00fado necess\u00e1rio para se adquirir profici\u00eancia com a ferramenta Git. O presente conte\u00fado deste projeto, foca em ser objetivo pra quem l\u00ea. As explica\u00e7\u00f5es visam atender o b\u00e1sico necess\u00e1rio para compreender como se utliza a ferramenta, assim como os seus benef\u00edcios. Este reposit\u00f3rio \u00e9 uma iniciativa para a cria\u00e7\u00e3o de cont\u00e9udo de forma colaborativa, Pull Requests s\u00e3o bem vindos! TODO: Sum\u00e1rio","title":"Bem vindo ao git-mini-book"},{"location":"git/about/","text":"O Que \u00e9? Pra Que Serve? O Git \u00e9 um Sistema de Controle Vers\u00f5es , criado para gerenciar fluxos de desenvolvimento de conte\u00fado de arquivos digitais, de forma objetiva, produtiva, perform\u00e1tica e distribu\u00edda. Seu uso \u00e9 amplo, tanto em projetos OpenSource ou Empresarias, principalmente os desenvolvidos de forma colaboradorativa. Atualmente, as linguagens C, Shell e Perl, predominam em seu c\u00f3digo fonte, que est\u00e1 acess\u00edvel no Github https://github.com/git/git Devido aos seus recursos, n\u00e3o \u00e9 errado associar o Git com as seguintes siglas de defini\u00e7\u00e3o de tecnologia: VSC - Version Control System , DVSC - Distributed Source Control Management ; SCM - Source Control Management ; RCS - Revision Control System . Por\u00e9m, \u00e9 importante entender que o Git n\u00e3o se restringe a exclusivamente uma sigla, e as associa\u00e7\u00f5es feitas, tem como base o contexto do qual est\u00e1 presente. Um Pouco da Hist\u00f3ria O Git teve origem no desenvolvimento do Kernel Linux. Durante os anos entre 1991 \u00e0 2002, as mudan\u00e7as introduzidas no c\u00f3digo fonte do Kernel, eram emitidas, em sua maior parte via email, por meio de anexos de tarballs . O processo, por mais arca\u00edco e inprodut\u00edvel que se possa aparecer, na vis\u00e3o de Linus Torvalds, criador e mantenedor do Linux, era melhor do que se utilizar as solu\u00e7\u00f5es presentes de VCS do mercado. Os patches eram recebidos pelo Linus, e o mesmo controlava o fluxo de colabora\u00e7\u00f5es manualmente. Ao passar do tempo, com base no grande volume de colabora\u00e7\u00f5es, complexidade e linhas de c\u00f3digos, tal fluxo de controle se tornou invi\u00e1vel, necessitando ent\u00e3o, a presen\u00e7a de um Sistema Distribu\u00eddo de Versionamento de Arquivos, comumente referenciado por DVSC - Distributed Version Control . Em 2002, foi adotado a tecnologia de DVSC propriet\u00e1ria BitKeeper para o controle do c\u00f3digo fonte do Linux. Em 2005, a empresa que desenvolveu o BitKeeper, removeu o acesso gratuito dos direitos autorais da ferramenta. Tal fato, que combinado com as limita\u00e7\u00f5es da ferramenta, levou a comunidade de desenvolvimento do Linux n\u00e3o prosseguir com o uso da ferramenta. Nenhuma solu\u00e7\u00e3o alternativa no mercado eram satisfat\u00f3rias, em especial no quesito de performance no ato de mesclar as contribui\u00e7\u00f5es no c\u00f3digo. Tal fato, levou a comunidade de desenvolvedores do Linux, em especial o pr\u00f3pio Linus, a criar uma solu\u00e7\u00e3o que tinha como meta, os seguintes pontos: Fazer o Oposto do CVS : N\u00e3o cometer os mesmos erros que a solu\u00e7\u00e3o existente CVS ; Desempenho : Velocidade para integrar colabora\u00e7\u00f5es; Distribu\u00eddo : Colobora\u00e7\u00f5es n\u00e3o necessariamente centralizadas, assim como a clareza de como se fazer os processos (pontos positivos herdados da experi\u00eancia com BitKeeper); Integridade : Mec\u00e2nismos internos para evitar o corrompimento de arquivos; Assim, em 2005, sob os termos da licensa GNU GPLv2 , o Git foi lan\u00e7ado. Com o decorrer do tempo, houve in\u00fameras melhorias, por\u00e9m as metas inicias foram preservadas. Atualmente \u00e9 a principal ferramenta de controle de vers\u00e3o, dominante nos projetos OpenSource . Caracteristicas Disponibilidade: Por mais que o Git se enquadre no formato DVSC - Distributed Source Control Management , boa parte de suas opera\u00e7\u00f5es s\u00e3o locais. Quando um projeto com Git \u00e9 clonado (baixado), a base de dados que cont\u00e9m os metadados do versionamento do projeto, ficam contidos no diret\u00f3rio .git na raiz do reposit\u00f3rio. Neste \u00e9 poss\u00edvel consultar o hist\u00f3rico sem a necessidade de conex\u00e3o com um servidor centralizado. Seguran\u00e7a: Para preservar a integridade dos arquivos, os mesmos s\u00e3o submetidos a fun\u00e7\u00e3o criptogr\u00e1fica SHA-1 , assim, corrompimentos de arquivos ser\u00e7\u00e3o detectados pelo Git. Gerencia de Estados : A principal diferen\u00e7a entre o Git e as demais solu\u00e7\u00f5es existentes de VCS, \u00e9 forma de como os dados s\u00e3o gerenciados. Como solu\u00e7\u00f5es existentes, podemos citar por exemplo o Subversion , Perforce e Bazaar Algumas das solu\u00e7\u00f5es existentes, fazem o controle de vers\u00f5es armazenando dados como altera\u00e7\u00f5es em uma vers\u00e3o b\u00e1sica de cada arquivo. Segue o exemplo: Diferetemente do formato exibido acima, o Git trata seus dados como um fluxo do estado dos arquivos . A cada commit , ou seja, a cada vez que for salvo o estado do projeto, \u00e9 criado um snapshot . O conte\u00fado deste snapshot \u00e9 composto pelas referencias dos arquivos presentes no momento. O Git \u00e9 inteligente ao ponto de manter a refer\u00eancia de um arquivo, caso n\u00e3o houver altera\u00e7\u00f5es no mesmo entre commits . Este formato, evita redundancia e possibilita benef\u00edcios como ramifica\u00e7\u00f5es e controles de conflitos de forma eficiente e perform\u00e1tica.","title":"Conceitos"},{"location":"git/about/#o-que-e-pra-que-serve","text":"O Git \u00e9 um Sistema de Controle Vers\u00f5es , criado para gerenciar fluxos de desenvolvimento de conte\u00fado de arquivos digitais, de forma objetiva, produtiva, perform\u00e1tica e distribu\u00edda. Seu uso \u00e9 amplo, tanto em projetos OpenSource ou Empresarias, principalmente os desenvolvidos de forma colaboradorativa. Atualmente, as linguagens C, Shell e Perl, predominam em seu c\u00f3digo fonte, que est\u00e1 acess\u00edvel no Github https://github.com/git/git Devido aos seus recursos, n\u00e3o \u00e9 errado associar o Git com as seguintes siglas de defini\u00e7\u00e3o de tecnologia: VSC - Version Control System , DVSC - Distributed Source Control Management ; SCM - Source Control Management ; RCS - Revision Control System . Por\u00e9m, \u00e9 importante entender que o Git n\u00e3o se restringe a exclusivamente uma sigla, e as associa\u00e7\u00f5es feitas, tem como base o contexto do qual est\u00e1 presente.","title":"O Que \u00e9? Pra Que Serve?"},{"location":"git/about/#um-pouco-da-historia","text":"O Git teve origem no desenvolvimento do Kernel Linux. Durante os anos entre 1991 \u00e0 2002, as mudan\u00e7as introduzidas no c\u00f3digo fonte do Kernel, eram emitidas, em sua maior parte via email, por meio de anexos de tarballs . O processo, por mais arca\u00edco e inprodut\u00edvel que se possa aparecer, na vis\u00e3o de Linus Torvalds, criador e mantenedor do Linux, era melhor do que se utilizar as solu\u00e7\u00f5es presentes de VCS do mercado. Os patches eram recebidos pelo Linus, e o mesmo controlava o fluxo de colabora\u00e7\u00f5es manualmente. Ao passar do tempo, com base no grande volume de colabora\u00e7\u00f5es, complexidade e linhas de c\u00f3digos, tal fluxo de controle se tornou invi\u00e1vel, necessitando ent\u00e3o, a presen\u00e7a de um Sistema Distribu\u00eddo de Versionamento de Arquivos, comumente referenciado por DVSC - Distributed Version Control . Em 2002, foi adotado a tecnologia de DVSC propriet\u00e1ria BitKeeper para o controle do c\u00f3digo fonte do Linux. Em 2005, a empresa que desenvolveu o BitKeeper, removeu o acesso gratuito dos direitos autorais da ferramenta. Tal fato, que combinado com as limita\u00e7\u00f5es da ferramenta, levou a comunidade de desenvolvimento do Linux n\u00e3o prosseguir com o uso da ferramenta. Nenhuma solu\u00e7\u00e3o alternativa no mercado eram satisfat\u00f3rias, em especial no quesito de performance no ato de mesclar as contribui\u00e7\u00f5es no c\u00f3digo. Tal fato, levou a comunidade de desenvolvedores do Linux, em especial o pr\u00f3pio Linus, a criar uma solu\u00e7\u00e3o que tinha como meta, os seguintes pontos: Fazer o Oposto do CVS : N\u00e3o cometer os mesmos erros que a solu\u00e7\u00e3o existente CVS ; Desempenho : Velocidade para integrar colabora\u00e7\u00f5es; Distribu\u00eddo : Colobora\u00e7\u00f5es n\u00e3o necessariamente centralizadas, assim como a clareza de como se fazer os processos (pontos positivos herdados da experi\u00eancia com BitKeeper); Integridade : Mec\u00e2nismos internos para evitar o corrompimento de arquivos; Assim, em 2005, sob os termos da licensa GNU GPLv2 , o Git foi lan\u00e7ado. Com o decorrer do tempo, houve in\u00fameras melhorias, por\u00e9m as metas inicias foram preservadas. Atualmente \u00e9 a principal ferramenta de controle de vers\u00e3o, dominante nos projetos OpenSource .","title":"Um Pouco da Hist\u00f3ria"},{"location":"git/about/#caracteristicas","text":"Disponibilidade: Por mais que o Git se enquadre no formato DVSC - Distributed Source Control Management , boa parte de suas opera\u00e7\u00f5es s\u00e3o locais. Quando um projeto com Git \u00e9 clonado (baixado), a base de dados que cont\u00e9m os metadados do versionamento do projeto, ficam contidos no diret\u00f3rio .git na raiz do reposit\u00f3rio. Neste \u00e9 poss\u00edvel consultar o hist\u00f3rico sem a necessidade de conex\u00e3o com um servidor centralizado. Seguran\u00e7a: Para preservar a integridade dos arquivos, os mesmos s\u00e3o submetidos a fun\u00e7\u00e3o criptogr\u00e1fica SHA-1 , assim, corrompimentos de arquivos ser\u00e7\u00e3o detectados pelo Git. Gerencia de Estados : A principal diferen\u00e7a entre o Git e as demais solu\u00e7\u00f5es existentes de VCS, \u00e9 forma de como os dados s\u00e3o gerenciados. Como solu\u00e7\u00f5es existentes, podemos citar por exemplo o Subversion , Perforce e Bazaar Algumas das solu\u00e7\u00f5es existentes, fazem o controle de vers\u00f5es armazenando dados como altera\u00e7\u00f5es em uma vers\u00e3o b\u00e1sica de cada arquivo. Segue o exemplo: Diferetemente do formato exibido acima, o Git trata seus dados como um fluxo do estado dos arquivos . A cada commit , ou seja, a cada vez que for salvo o estado do projeto, \u00e9 criado um snapshot . O conte\u00fado deste snapshot \u00e9 composto pelas referencias dos arquivos presentes no momento. O Git \u00e9 inteligente ao ponto de manter a refer\u00eancia de um arquivo, caso n\u00e3o houver altera\u00e7\u00f5es no mesmo entre commits . Este formato, evita redundancia e possibilita benef\u00edcios como ramifica\u00e7\u00f5es e controles de conflitos de forma eficiente e perform\u00e1tica.","title":"Caracteristicas"},{"location":"git/cli-branch/","text":"TODO: git rebase , git reset DOING: git branch , git checkout , git merge OK: git tag , Ramifica\u00e7\u00f5es Branches Listar as branches locais git branch Lista todas as branches presentes no projeto, levando em considera\u00e7\u00e3o as branches remotas git branch -a Criar uma nova ramifica\u00e7\u00e3o a partir da branch atual git checkout -b <NOME-DA-BRANCH> Mudar o ambiente para a branch especificada. Para mudar o ambiente, \u00e9 necess\u00e1rio que todos os arquivos estejam no estado git checkout <NOME-DA-BRANCH> Mesclar as mudan\u00e7as, na branch atual , as modifica\u00e7\u00f5es feitas na branch indicada em <NOME-DA-BRANCH> git merge <NOME-DA-BRANCH> Mostrar as linhas de modificados entra as tag's indicadas git diff <TAG-1> <TAG-2> Tags O comando git tag , adicionar um r\u00f3tulo a um commit , ou seja, um atalho em alto n\u00edvel a um determinado hash de um commit espec\u00edfico. Pode se compreender que uma tag , \u00e9 uma branch que n\u00e3o muda, normalmente utilizadas para indicar pontos de interesses no projeto, como por exemplo, vers\u00f5es est\u00e1veis, de homologa\u00e7\u00e3o e vers\u00f5es testes. Antes de verificar os comandos, \u00e9 importante saber que existem dois tipo de tags, Leve ( unannotated ) e Anotada ( annotated ). As Tags Leves, ponteiro simples para um commit existente. J\u00e1 as Tags Anotadas s\u00e3o objetos completos armazenados no banco de dados Git, contendo o nome, o email do autor de sua cria\u00e7\u00e3o, em conjunto com a data de cria\u00e7\u00e3o, somados a uma uma mensagem de marca\u00e7\u00e3o. Listar todas as tag's do projeto com a mensagem de marca\u00e7\u00e3o git tag -n Caso alguma Tag Leve seja listada, a mensagem de marca\u00e7\u00e3o ser\u00e1 a mesma do commit da qual a mesma faz refer\u00eancia. Criar Tag do Tipo Anotada: git tag -a <NOME-DA-TAG> -m \"<MENSAGEM-DESCRITIVA-DA-TAG>\" Criar uma Tag do Tipo leve, git tag <NOME-DA-TAG> Adicionar uma Tag a um Commit espec\u00edfico: git tag -a <NOME-DA-TAG> -m \"<MENSAGEM-DESCRITIVA-DA-TAG>\" <HASH-DO-COMMIT> Se n\u00e3o passado o argumento -a , a Tag criada ser\u00e1 do tipo Leve:","title":"Ramifica\u00e7\u00f5es"},{"location":"git/cli-branch/#ramificacoes","text":"","title":"Ramifica\u00e7\u00f5es"},{"location":"git/cli-branch/#branches","text":"Listar as branches locais git branch Lista todas as branches presentes no projeto, levando em considera\u00e7\u00e3o as branches remotas git branch -a Criar uma nova ramifica\u00e7\u00e3o a partir da branch atual git checkout -b <NOME-DA-BRANCH> Mudar o ambiente para a branch especificada. Para mudar o ambiente, \u00e9 necess\u00e1rio que todos os arquivos estejam no estado git checkout <NOME-DA-BRANCH> Mesclar as mudan\u00e7as, na branch atual , as modifica\u00e7\u00f5es feitas na branch indicada em <NOME-DA-BRANCH> git merge <NOME-DA-BRANCH> Mostrar as linhas de modificados entra as tag's indicadas git diff <TAG-1> <TAG-2>","title":"Branches"},{"location":"git/cli-branch/#tags","text":"O comando git tag , adicionar um r\u00f3tulo a um commit , ou seja, um atalho em alto n\u00edvel a um determinado hash de um commit espec\u00edfico. Pode se compreender que uma tag , \u00e9 uma branch que n\u00e3o muda, normalmente utilizadas para indicar pontos de interesses no projeto, como por exemplo, vers\u00f5es est\u00e1veis, de homologa\u00e7\u00e3o e vers\u00f5es testes. Antes de verificar os comandos, \u00e9 importante saber que existem dois tipo de tags, Leve ( unannotated ) e Anotada ( annotated ). As Tags Leves, ponteiro simples para um commit existente. J\u00e1 as Tags Anotadas s\u00e3o objetos completos armazenados no banco de dados Git, contendo o nome, o email do autor de sua cria\u00e7\u00e3o, em conjunto com a data de cria\u00e7\u00e3o, somados a uma uma mensagem de marca\u00e7\u00e3o. Listar todas as tag's do projeto com a mensagem de marca\u00e7\u00e3o git tag -n Caso alguma Tag Leve seja listada, a mensagem de marca\u00e7\u00e3o ser\u00e1 a mesma do commit da qual a mesma faz refer\u00eancia. Criar Tag do Tipo Anotada: git tag -a <NOME-DA-TAG> -m \"<MENSAGEM-DESCRITIVA-DA-TAG>\" Criar uma Tag do Tipo leve, git tag <NOME-DA-TAG> Adicionar uma Tag a um Commit espec\u00edfico: git tag -a <NOME-DA-TAG> -m \"<MENSAGEM-DESCRITIVA-DA-TAG>\" <HASH-DO-COMMIT> Se n\u00e3o passado o argumento -a , a Tag criada ser\u00e1 do tipo Leve:","title":"Tags"},{"location":"git/cli-config/","text":"Configura\u00e7\u00e3o Local O comando git config faz a personaliza\u00e7\u00e3o local do utilit\u00e1rio. Com ele \u00e9 poss\u00edvel definir o nome e email do autor que introduz as colabora\u00e7\u00f5es, o editor de texto que o git vai chamar quando algum comando precisar de uma entrada de texto, entre outras funcionalidades. Se o comando git config for executado com o argumento --system , os valores ser\u00e3o formatados e salvos no arquivo /etc/gitconfig . Assim, todos os usu\u00e1rios do sistema ter\u00e3o as informa\u00e7\u00f5es contidos neste como padr\u00e3o. Caso o argumento passado for --global , os valores ser\u00e3o salvos em ~/.gitconfig , e valer\u00e3o como padr\u00e3o para o usu\u00e1rio de sistema do qual o executou. Caso n\u00e3o for passado nenhum dos argumentos citados, e o usu\u00e1rio estiver em um Working Directory , ou seja, em reposit\u00f3rio local, o arquivo alterado ser\u00e1 o .git/config . Assim, a ordem de sobrescrita dos metadados do git config , se d\u00e1 pela seguinte ordem: /etc/gitconfig : Base de valores \u00e0 nivel System Wide , ou seja, para todos os usu\u00e1rios; ~/.gitconfig : Valores a n\u00edvel de Usu\u00e1rio de Sistema - Sobrescreve o /etc/gitconfig ; .git/config : Valores a n\u00edvel de projeto - Sobrescreve o /etc/gitconfig e ~/.gitconfig . Indicar o nome da pessoa que esta fazendo as altera\u00e7\u00f5es no projeto: git config user.email \"carlos.neto.dev@gmail\" O valor \"carlos.neto.dev@gmail\" \u00e9 o nome exemplo do usu\u00e1rio Indicar o nome da pessoa que esta fazendo as altera\u00e7\u00f5es no projeto: git config --global user.name \"Carlos Neto\" O valor \"Carlos Neto\" \u00e9 o nome exemplo do usu\u00e1rio Indicar o editor de texto que o git ir\u00e1 chamar quando for necess\u00e1rio escrever alguma mensagem : git config core.editor /usr/bin/code --wait O valor /usr/bin/code \u00e9 o caminho ilustrativo de um VSCode. Este \u00e9 o valor que deve ser alterado para o caminho absoluto do bin\u00e1rio do editor de texto de sua prefer\u00eancia.","title":"Configura\u00e7\u00e3o"},{"location":"git/cli-config/#configuracao-local","text":"O comando git config faz a personaliza\u00e7\u00e3o local do utilit\u00e1rio. Com ele \u00e9 poss\u00edvel definir o nome e email do autor que introduz as colabora\u00e7\u00f5es, o editor de texto que o git vai chamar quando algum comando precisar de uma entrada de texto, entre outras funcionalidades. Se o comando git config for executado com o argumento --system , os valores ser\u00e3o formatados e salvos no arquivo /etc/gitconfig . Assim, todos os usu\u00e1rios do sistema ter\u00e3o as informa\u00e7\u00f5es contidos neste como padr\u00e3o. Caso o argumento passado for --global , os valores ser\u00e3o salvos em ~/.gitconfig , e valer\u00e3o como padr\u00e3o para o usu\u00e1rio de sistema do qual o executou. Caso n\u00e3o for passado nenhum dos argumentos citados, e o usu\u00e1rio estiver em um Working Directory , ou seja, em reposit\u00f3rio local, o arquivo alterado ser\u00e1 o .git/config . Assim, a ordem de sobrescrita dos metadados do git config , se d\u00e1 pela seguinte ordem: /etc/gitconfig : Base de valores \u00e0 nivel System Wide , ou seja, para todos os usu\u00e1rios; ~/.gitconfig : Valores a n\u00edvel de Usu\u00e1rio de Sistema - Sobrescreve o /etc/gitconfig ; .git/config : Valores a n\u00edvel de projeto - Sobrescreve o /etc/gitconfig e ~/.gitconfig . Indicar o nome da pessoa que esta fazendo as altera\u00e7\u00f5es no projeto: git config user.email \"carlos.neto.dev@gmail\" O valor \"carlos.neto.dev@gmail\" \u00e9 o nome exemplo do usu\u00e1rio Indicar o nome da pessoa que esta fazendo as altera\u00e7\u00f5es no projeto: git config --global user.name \"Carlos Neto\" O valor \"Carlos Neto\" \u00e9 o nome exemplo do usu\u00e1rio Indicar o editor de texto que o git ir\u00e1 chamar quando for necess\u00e1rio escrever alguma mensagem : git config core.editor /usr/bin/code --wait O valor /usr/bin/code \u00e9 o caminho ilustrativo de um VSCode. Este \u00e9 o valor que deve ser alterado para o caminho absoluto do bin\u00e1rio do editor de texto de sua prefer\u00eancia.","title":"Configura\u00e7\u00e3o Local"},{"location":"git/cli-logs/","text":"Comandos de Consulta Verifica o hist\u00f3rico de commits, com seu respectivo hash, autor e data git log git log --pretty=format: %d %cn --graph","title":"Consultas"},{"location":"git/cli-logs/#comandos-de-consulta","text":"Verifica o hist\u00f3rico de commits, com seu respectivo hash, autor e data git log git log --pretty=format: %d %cn --graph","title":"Comandos de Consulta"},{"location":"git/cli-remote/","text":"Comandos de Opera\u00e7\u00f5es Remotas Clonar o projeto de um servidor externo: git clone <URL-DO-PROJETO> Normalmente, h\u00e1 diferen\u00e7a em associar o ato de obter um projeto remoto, com os termos Clonar ( clone ) e Baixar ( download ). Quando clonamos , obtemos o diret\u00f3rio .git do projeto, assim, a base de dados do versionamento projeto. Quando baixamos , apenas obtemos o conte\u00fado do projeto, sem a presen\u00e7a do diret\u00f3rio .git Sincronizar as refer\u00eancias externas com a base de dados local: git fetch Pode-se compreender em Sincronizar Refer\u00eancias Externas como atualizar a Base Local de versionamento com novas branches e tags criadas ap\u00f3s o clone do projeto. Associar a Base Local de a um reposit\u00f3rio remoto. git remote add <APELIDO-DO-REPOSITORIO-REMOTO> <URL-REPOSITORIO-REMOTO> O par\u00e2metro , \u00e9 um apelido de associa\u00e7\u00e3o para o reposit\u00f3rio externo. Por conven\u00e7\u00e3o, o valor de para associar o reposit\u00f3rio externo princial do projet \u00e9: origin . \u00c9 poss\u00edvel ter mais do que um reposit\u00f3rio externo vinculados a Base Local. Enviar as altera\u00e7\u00f5es que est\u00e3o no status Commited presentes na Base Local, para a base de um reposit\u00f3rio remoto. git push <APELIDO-DO-REPOSITORIO-REMOTO> <NOME-DA-BRANCHE> O par\u00e2metro indica para qual reposit\u00f3rio externo as modifica\u00e7\u00f5es ser\u00e3o enviadas as altera\u00e7\u00f5es em estado Commited . Obter as altera\u00e7\u00f5es de um reposit\u00f3rio externo com a Base Local. git pull origin main O par\u00e2metro origin , indica de qual reposit\u00f3rio externo as modifica\u00e7\u00f5es ser\u00e3o enviadas. Observa\u00e7\u00f5es Importantes : O comando s\u00f3 ter\u00e1 efeito caso n\u00e3o tenha nenhum arquivo com o status Untracked na Base Local; Caso algum ;","title":"Opera\u00e7\u00f5es Remotas"},{"location":"git/cli-remote/#comandos-de-operacoes-remotas","text":"Clonar o projeto de um servidor externo: git clone <URL-DO-PROJETO> Normalmente, h\u00e1 diferen\u00e7a em associar o ato de obter um projeto remoto, com os termos Clonar ( clone ) e Baixar ( download ). Quando clonamos , obtemos o diret\u00f3rio .git do projeto, assim, a base de dados do versionamento projeto. Quando baixamos , apenas obtemos o conte\u00fado do projeto, sem a presen\u00e7a do diret\u00f3rio .git Sincronizar as refer\u00eancias externas com a base de dados local: git fetch Pode-se compreender em Sincronizar Refer\u00eancias Externas como atualizar a Base Local de versionamento com novas branches e tags criadas ap\u00f3s o clone do projeto. Associar a Base Local de a um reposit\u00f3rio remoto. git remote add <APELIDO-DO-REPOSITORIO-REMOTO> <URL-REPOSITORIO-REMOTO> O par\u00e2metro , \u00e9 um apelido de associa\u00e7\u00e3o para o reposit\u00f3rio externo. Por conven\u00e7\u00e3o, o valor de para associar o reposit\u00f3rio externo princial do projet \u00e9: origin . \u00c9 poss\u00edvel ter mais do que um reposit\u00f3rio externo vinculados a Base Local. Enviar as altera\u00e7\u00f5es que est\u00e3o no status Commited presentes na Base Local, para a base de um reposit\u00f3rio remoto. git push <APELIDO-DO-REPOSITORIO-REMOTO> <NOME-DA-BRANCHE> O par\u00e2metro indica para qual reposit\u00f3rio externo as modifica\u00e7\u00f5es ser\u00e3o enviadas as altera\u00e7\u00f5es em estado Commited . Obter as altera\u00e7\u00f5es de um reposit\u00f3rio externo com a Base Local. git pull origin main O par\u00e2metro origin , indica de qual reposit\u00f3rio externo as modifica\u00e7\u00f5es ser\u00e3o enviadas. Observa\u00e7\u00f5es Importantes : O comando s\u00f3 ter\u00e1 efeito caso n\u00e3o tenha nenhum arquivo com o status Untracked na Base Local; Caso algum ;","title":"Comandos de Opera\u00e7\u00f5es Remotas"},{"location":"git/cli-state/","text":"OK: git init , git add , git rm , git mv , git commit , git sparse-checkout , git restore , git revert TODO: git mv , git sparse-checkout , git restore , git revert Comandos de Mudan\u00e7as de Status Um arquivo pode estar tr\u00eas areas : Working Directory : N\u00e3o indexados na base local; INDEX \u2014 aka : Staging : Prontos para serem indexados a base local; HEAD \u2014 aka : .git : Indexados na base local. Nestas \u00e1reas, um arquivo pode conter os seguintes status : Untracked : Quando o arquivo est\u00e1 em Working Directory ; Staged \u2014 aka Tracked : Quando o arquivo est\u00e1 no INDEX . Unmodified : Arquivos no INDEX que n\u00e3o tiveram altera\u00e7\u00f5es entre commits ; Modified : Arquivos no INDEX que tiveram altera\u00e7\u00f5es entre commits ; Commited \u2014 aka HEAD : Arquivos indexados na base de dados do Git. Criar um Working Directory , ou seja um reposit\u00f3rio Git: git init O comando ir\u00e1 criar o diret\u00f3rio .git , que \u00e9 a base local do versionamento do projeto. Mudar o status do arquivo ou diret\u00f3rio de: Untracked para Staged git add <ARQUIVO-OU-DIRET\u00d3RIO> Caso informa o arquivo, ser\u00e1 mudado status somente do mesmo, caso informado um diret\u00f3rio, ser\u00e1 mudificado o status dos arquivos presentes neste de forma recursiva: Mudar o status do arquivo de: Staged para Untracked git rm --cached <ARQUIVO> Mudar o status do diret\u00f3rio de: Staged para Untracked git rm -r --cached <DIRET\u00d3RIO> O par\u00e2metro --cached , caso n\u00e3o informado, remover\u00e1 o arquivo do sistema operacional, assim como o comando rm convencional do Linux Mudar o status de Staged para Commited : git commit <ARQUIVO-OU-DIRETORIO> -m <MENSAGEM> O par\u00e2metro -m indica uma mensagem que descreve a mudan\u00e7a que foi feita neste arquivo. Caso n\u00e3o seja indicado, ser\u00e1 aberto o editor de texto, configurado no comando git config core.editor","title":"Mudan\u00e7a de Estados"},{"location":"git/cli-state/#comandos-de-mudancas-de-status","text":"Um arquivo pode estar tr\u00eas areas : Working Directory : N\u00e3o indexados na base local; INDEX \u2014 aka : Staging : Prontos para serem indexados a base local; HEAD \u2014 aka : .git : Indexados na base local. Nestas \u00e1reas, um arquivo pode conter os seguintes status : Untracked : Quando o arquivo est\u00e1 em Working Directory ; Staged \u2014 aka Tracked : Quando o arquivo est\u00e1 no INDEX . Unmodified : Arquivos no INDEX que n\u00e3o tiveram altera\u00e7\u00f5es entre commits ; Modified : Arquivos no INDEX que tiveram altera\u00e7\u00f5es entre commits ; Commited \u2014 aka HEAD : Arquivos indexados na base de dados do Git. Criar um Working Directory , ou seja um reposit\u00f3rio Git: git init O comando ir\u00e1 criar o diret\u00f3rio .git , que \u00e9 a base local do versionamento do projeto. Mudar o status do arquivo ou diret\u00f3rio de: Untracked para Staged git add <ARQUIVO-OU-DIRET\u00d3RIO> Caso informa o arquivo, ser\u00e1 mudado status somente do mesmo, caso informado um diret\u00f3rio, ser\u00e1 mudificado o status dos arquivos presentes neste de forma recursiva: Mudar o status do arquivo de: Staged para Untracked git rm --cached <ARQUIVO> Mudar o status do diret\u00f3rio de: Staged para Untracked git rm -r --cached <DIRET\u00d3RIO> O par\u00e2metro --cached , caso n\u00e3o informado, remover\u00e1 o arquivo do sistema operacional, assim como o comando rm convencional do Linux Mudar o status de Staged para Commited : git commit <ARQUIVO-OU-DIRETORIO> -m <MENSAGEM> O par\u00e2metro -m indica uma mensagem que descreve a mudan\u00e7a que foi feita neste arquivo. Caso n\u00e3o seja indicado, ser\u00e1 aberto o editor de texto, configurado no comando git config core.editor","title":"Comandos de Mudan\u00e7as de Status"},{"location":"git/cli/","text":"Git CLI As maneiras convencionais de se utilizar o Git, s\u00e3o por meio de sua CLI \u2014 utilit\u00e1rio de linha de comando \u2014 e por solu\u00e7\u00f5es de interface gr\u00e1fica. Alguma das solu\u00e7\u00f5es de suite gr\u00e1ficas s\u00e3o: GitKraken : Su\u00edte Gr\u00e1fica focada nas funcionalidades do Git; VSCode : Editor de texto, que por padr\u00e3o, oferece as funcionalidades b\u00e1sicas do Git de forma visual; IDEs da JetBrains : Ambientes de Desenvolvimentos Integrados para Python, Java, Golang e etc, que assim como VSCode, oferece recursos visuais para intera\u00e7\u00e3o com o Git. Instala\u00e7\u00e3o : Em distribui\u00e7\u00f5es Linux, a CLI do Git normalmente est\u00e1 dispon\u00edvel nos reposit\u00f3rios oficias. J\u00e1 em sistemas Windows ou MacOS, o processo de instala\u00e7\u00e3o \u00e9 feito por meio de instaladores com interface gr\u00e1fica. Para mais detalhes, acessar o guia de instala\u00e7\u00e3o oficial Todas as funcionalidades est\u00e3o dispon\u00edveis na CLI, fato que n\u00e3o necessariamente \u00e9 verdade para as solu\u00e7\u00f5es de su\u00edte gr\u00e1fica. Esta se\u00e7\u00e3o, ir\u00e1 focar na explora\u00e7\u00e3o dos recursos do Git via CLI. O conte\u00fado ser\u00e1 organizado da seguinte forma: Configura\u00e7\u00e3o : Configura\u00e7\u00e3o de metadados de identidade; git config Controle de Estados : Controle de areas e status do ciclo de vida de versionamento de arquivos; git init , git add , git rm , git mv , git commit , git sparse-checkout , git restore Ramifica\u00e7\u00f5es : Opera\u00e7\u00f5es de branching , como cria\u00e7\u00e3o de ramifica\u00e7\u00e3o e mescla de conte\u00fado; git branch , git checkout , git merge , git rebase , git reset , git tag Opera\u00e7\u00f5es Remotas : Opera\u00e7\u00f5es de sincroniza\u00e7\u00e3o com reposit\u00f3rios externos; git push , git pull , git fetch , git remote Consulta de Hist\u00f3rico : Verifica\u00e7\u00e3o do hist\u00f3rico de versionamento. git log , git diff , git show , git status , git grep , git bisect","title":"Git CLI"},{"location":"git/cli/#git-cli","text":"As maneiras convencionais de se utilizar o Git, s\u00e3o por meio de sua CLI \u2014 utilit\u00e1rio de linha de comando \u2014 e por solu\u00e7\u00f5es de interface gr\u00e1fica. Alguma das solu\u00e7\u00f5es de suite gr\u00e1ficas s\u00e3o: GitKraken : Su\u00edte Gr\u00e1fica focada nas funcionalidades do Git; VSCode : Editor de texto, que por padr\u00e3o, oferece as funcionalidades b\u00e1sicas do Git de forma visual; IDEs da JetBrains : Ambientes de Desenvolvimentos Integrados para Python, Java, Golang e etc, que assim como VSCode, oferece recursos visuais para intera\u00e7\u00e3o com o Git. Instala\u00e7\u00e3o : Em distribui\u00e7\u00f5es Linux, a CLI do Git normalmente est\u00e1 dispon\u00edvel nos reposit\u00f3rios oficias. J\u00e1 em sistemas Windows ou MacOS, o processo de instala\u00e7\u00e3o \u00e9 feito por meio de instaladores com interface gr\u00e1fica. Para mais detalhes, acessar o guia de instala\u00e7\u00e3o oficial Todas as funcionalidades est\u00e3o dispon\u00edveis na CLI, fato que n\u00e3o necessariamente \u00e9 verdade para as solu\u00e7\u00f5es de su\u00edte gr\u00e1fica. Esta se\u00e7\u00e3o, ir\u00e1 focar na explora\u00e7\u00e3o dos recursos do Git via CLI. O conte\u00fado ser\u00e1 organizado da seguinte forma: Configura\u00e7\u00e3o : Configura\u00e7\u00e3o de metadados de identidade; git config Controle de Estados : Controle de areas e status do ciclo de vida de versionamento de arquivos; git init , git add , git rm , git mv , git commit , git sparse-checkout , git restore Ramifica\u00e7\u00f5es : Opera\u00e7\u00f5es de branching , como cria\u00e7\u00e3o de ramifica\u00e7\u00e3o e mescla de conte\u00fado; git branch , git checkout , git merge , git rebase , git reset , git tag Opera\u00e7\u00f5es Remotas : Opera\u00e7\u00f5es de sincroniza\u00e7\u00e3o com reposit\u00f3rios externos; git push , git pull , git fetch , git remote Consulta de Hist\u00f3rico : Verifica\u00e7\u00e3o do hist\u00f3rico de versionamento. git log , git diff , git show , git status , git grep , git bisect","title":"Git CLI"},{"location":"plataformas/about/","text":"","title":"About"},{"location":"plataformas/github/","text":"Github https://www.gitmemory.com/augustoliks/supervisord-fastapi","title":"Github"},{"location":"plataformas/github/#github","text":"https://www.gitmemory.com/augustoliks/supervisord-fastapi","title":"Github"},{"location":"plataformas/gitlab/","text":"Gitlab TODO: Conteudo do curso de certifica\u00e7\u00e3o Gitlab-Flow TODO: Transcrever o conteudo Gitlab-Components TODO: Transcrever o conteudo","title":"Gitlab"},{"location":"plataformas/gitlab/#gitlab","text":"TODO: Conteudo do curso de certifica\u00e7\u00e3o","title":"Gitlab"},{"location":"plataformas/gitlab/#gitlab-flow","text":"TODO: Transcrever o conteudo","title":"Gitlab-Flow"},{"location":"plataformas/gitlab/#gitlab-components","text":"TODO: Transcrever o conteudo","title":"Gitlab-Components"},{"location":"workflows/about/","text":"","title":"About"},{"location":"workflows/git-flow/","text":"Git Flow O Git Flow, \u00e9 uma maneira padronizada para se trabalhar com recursos do Git, focado principalmente, para se obter uma produtividade elevada sobre o um projeto com muitos desenvolvedores. Quando tiver trabalhando em equipe evite desenvolver no branch main pois poder\u00e1 dar muitos conflitos. Sempre crie um branch para fazer suas modifica\u00e7\u00f5es. Por exemplo, voc\u00ea vai desenvolver uma funcionalidade nova para listar os clientes do banco de dados, voc\u00ea poderia criar um novo branch chamado clientes e trabalhar nesse branch para depois jogar ao main Terminologias branch-main : Branch principal do projeto, contendo somente as vers\u00f5es est\u00e1veis do projeto. As tags representar\u00e3o vers\u00f5es do projeto; branch-develop : Centraliza todo o processo de desenvolvimento atual do projeto; branch-feature : Ramifica\u00e7\u00f5es para se criar um ambiente isolado, que ser\u00e1m o escopo para se adicionar uma nova funcionalidade ao projeto. S\u00e3o criadas e mergeadas sempre na develop ; branch-hotfix : Branches locais, geradas e posteriormente incorporadas na main , criadas a fim de solucionar um bug que est\u00e1 presente uma vers\u00e3o em produ\u00e7\u00e3o; branch-release : Branches locais, geradas na develop e posteriormente incorporadas na main e na develop subsequentemente. Servem para a cria\u00e7\u00e3o de uma nova vers\u00e3o de produ\u00e7\u00e3o, em conjunto com a documenta\u00e7\u00e3o do que foi feita na mesma; fork : Pode-se entender como uma ado\u00e7\u00e3o/clone de um projeto j\u00e1 existente, para sua conta. \u00c9 possivel solicitar que as mudan\u00e7as feitas sejam aderidas no projeto oriundos do fork em quest\u00e3o, em que as mudan\u00e7as ficam pendentes, mediantes a aprova\u00e7\u00e3o do mantenedor do projeto. Flow Branch de Features Cria\u00e7\u00e3o de uma branch-feature . $ git checkout develop $ git pull origin develop $ git checkout -b ArrumandoLayout Incorporando tais modifica\u00e7\u00f5es na branch-develop $ git checkout develop $ git pull origin develop $ git merge --no-ff ArrumandoLayout $ git branch -d ArrumandoLayout $ git push origin develop Cria\u00e7\u00e3o de Branche de vers\u00e3o (Release Branch) Criando branch local denominada release-0.1.0 , apenas para fazer a versionamento. O bump-version \u00e9 um shell script que ir\u00e1 pegar o nome de cada commit dado na respectiva vers\u00e3o, e criar um arquivo texto com o nome da vers\u00e3o e os commits, isto serve para deixam de uma maneira clara o que foi feita em cada vers\u00e3o. $ git checkout develop $ git pull origin develop $ git checkout -b release-0.1.0 $ git fetch origin --tags # Documenta o que foi feito # Altera os arquivos de gerenciamento de build, como por exemplo: pom.xml ( maven ) ; rpm.spec ( Pacotes RPM ) ; e poetry.lock ( Python ) etc... $ git commit -a -m \"Vers\u00e3o alterada para 0.1.0\" Inserindo na main $ git checkout main $ git pull origin main $ git merge --no-ff release-0.1.0 $ git push origin main $ git tag -a v0.1.0 -m \"Vers\u00e3o 0.1.0\" $ git push origin --tags Feito o versionamento na main, \u00e9 hora de incorporar tais commits que representar\u00e3o a cria\u00e7\u00e3o de nova vers\u00e3o $ git checkout develop $ git merge --no-ff release-0.1.0 $ git branch -d release-0.1.0 Hotfix Gerando branch de hotfix a partir da main $ git checkout main $ git pull origin main $ git checkout -b hotfix-0.1.1 $ git fetch origin --tags # Faz as altera\u00e7\u00f5es necess\u00e1rias # Documenta o que foi feito # Altera os arquivos de gerenciamento de build, como por exemplo: pom.xml ( maven ) ; rpm.spec ( Pacotes RPM ) ; e poetry.lock ( Python ) etc... $ git commit -a -m \"Vers\u00e3o alterada 0.1.1\" Incorporando hotfix na main $ git checkout main $ git pull origin main $ git merge --no-ff hotfix-0.1.1 $ git push origin main $ git tag -a v0.1.1 -m \"hotfix-0.1.1 - Corre\u00e7\u00e3o do bug X\" $ git push origin --tags Integrando na develop. $ git checkout develop $ git pull origin develop $ git merge --no-ff hotfix-0.1.1 Caso h\u00e1 branch do tipo release . Elas tamb\u00e9m dever\u00e3o incorporar as altera\u00e7\u00f5es da hotfix. $ git branch -d hotfix-0.1.1","title":"Git Flow"},{"location":"workflows/git-flow/#git-flow","text":"O Git Flow, \u00e9 uma maneira padronizada para se trabalhar com recursos do Git, focado principalmente, para se obter uma produtividade elevada sobre o um projeto com muitos desenvolvedores. Quando tiver trabalhando em equipe evite desenvolver no branch main pois poder\u00e1 dar muitos conflitos. Sempre crie um branch para fazer suas modifica\u00e7\u00f5es. Por exemplo, voc\u00ea vai desenvolver uma funcionalidade nova para listar os clientes do banco de dados, voc\u00ea poderia criar um novo branch chamado clientes e trabalhar nesse branch para depois jogar ao main","title":"Git Flow"},{"location":"workflows/git-flow/#terminologias","text":"branch-main : Branch principal do projeto, contendo somente as vers\u00f5es est\u00e1veis do projeto. As tags representar\u00e3o vers\u00f5es do projeto; branch-develop : Centraliza todo o processo de desenvolvimento atual do projeto; branch-feature : Ramifica\u00e7\u00f5es para se criar um ambiente isolado, que ser\u00e1m o escopo para se adicionar uma nova funcionalidade ao projeto. S\u00e3o criadas e mergeadas sempre na develop ; branch-hotfix : Branches locais, geradas e posteriormente incorporadas na main , criadas a fim de solucionar um bug que est\u00e1 presente uma vers\u00e3o em produ\u00e7\u00e3o; branch-release : Branches locais, geradas na develop e posteriormente incorporadas na main e na develop subsequentemente. Servem para a cria\u00e7\u00e3o de uma nova vers\u00e3o de produ\u00e7\u00e3o, em conjunto com a documenta\u00e7\u00e3o do que foi feita na mesma; fork : Pode-se entender como uma ado\u00e7\u00e3o/clone de um projeto j\u00e1 existente, para sua conta. \u00c9 possivel solicitar que as mudan\u00e7as feitas sejam aderidas no projeto oriundos do fork em quest\u00e3o, em que as mudan\u00e7as ficam pendentes, mediantes a aprova\u00e7\u00e3o do mantenedor do projeto.","title":"Terminologias"},{"location":"workflows/git-flow/#flow","text":"","title":"Flow"},{"location":"workflows/git-flow/#branch-de-features","text":"Cria\u00e7\u00e3o de uma branch-feature . $ git checkout develop $ git pull origin develop $ git checkout -b ArrumandoLayout Incorporando tais modifica\u00e7\u00f5es na branch-develop $ git checkout develop $ git pull origin develop $ git merge --no-ff ArrumandoLayout $ git branch -d ArrumandoLayout $ git push origin develop","title":"Branch de Features"},{"location":"workflows/git-flow/#criacao-de-branche-de-versao-release-branch","text":"Criando branch local denominada release-0.1.0 , apenas para fazer a versionamento. O bump-version \u00e9 um shell script que ir\u00e1 pegar o nome de cada commit dado na respectiva vers\u00e3o, e criar um arquivo texto com o nome da vers\u00e3o e os commits, isto serve para deixam de uma maneira clara o que foi feita em cada vers\u00e3o. $ git checkout develop $ git pull origin develop $ git checkout -b release-0.1.0 $ git fetch origin --tags # Documenta o que foi feito # Altera os arquivos de gerenciamento de build, como por exemplo: pom.xml ( maven ) ; rpm.spec ( Pacotes RPM ) ; e poetry.lock ( Python ) etc... $ git commit -a -m \"Vers\u00e3o alterada para 0.1.0\" Inserindo na main $ git checkout main $ git pull origin main $ git merge --no-ff release-0.1.0 $ git push origin main $ git tag -a v0.1.0 -m \"Vers\u00e3o 0.1.0\" $ git push origin --tags Feito o versionamento na main, \u00e9 hora de incorporar tais commits que representar\u00e3o a cria\u00e7\u00e3o de nova vers\u00e3o $ git checkout develop $ git merge --no-ff release-0.1.0 $ git branch -d release-0.1.0","title":"Cria\u00e7\u00e3o de Branche de vers\u00e3o (Release Branch)"},{"location":"workflows/git-flow/#hotfix","text":"Gerando branch de hotfix a partir da main $ git checkout main $ git pull origin main $ git checkout -b hotfix-0.1.1 $ git fetch origin --tags # Faz as altera\u00e7\u00f5es necess\u00e1rias # Documenta o que foi feito # Altera os arquivos de gerenciamento de build, como por exemplo: pom.xml ( maven ) ; rpm.spec ( Pacotes RPM ) ; e poetry.lock ( Python ) etc... $ git commit -a -m \"Vers\u00e3o alterada 0.1.1\" Incorporando hotfix na main $ git checkout main $ git pull origin main $ git merge --no-ff hotfix-0.1.1 $ git push origin main $ git tag -a v0.1.1 -m \"hotfix-0.1.1 - Corre\u00e7\u00e3o do bug X\" $ git push origin --tags Integrando na develop. $ git checkout develop $ git pull origin develop $ git merge --no-ff hotfix-0.1.1 Caso h\u00e1 branch do tipo release . Elas tamb\u00e9m dever\u00e3o incorporar as altera\u00e7\u00f5es da hotfix. $ git branch -d hotfix-0.1.1","title":"Hotfix"},{"location":"workflows/github-flow/","text":"Github Flow","title":"Github Flow"},{"location":"workflows/github-flow/#github-flow","text":"","title":"Github Flow"},{"location":"workflows/gitlab-flow/","text":"Gitlab Flow","title":"Gitlab Flow"},{"location":"workflows/gitlab-flow/#gitlab-flow","text":"","title":"Gitlab Flow"}]}